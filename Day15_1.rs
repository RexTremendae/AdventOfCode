use std::collections::HashMap;
use std::vec::Vec;
use std::cmp;

type Address = i64;
type InstructionByte = i64;
type IOData = i64;

#[derive(Debug)]
enum ParameterMode
{
    Positional,
    Immediate,
    Relative
}

#[derive(Debug)]
enum Instruction
{
    Exit,
    Add(ParameterMode, ParameterMode, ParameterMode),
    Multiply(ParameterMode, ParameterMode, ParameterMode),
    Input(ParameterMode),
    Output(ParameterMode),
    JumpIfTrue(ParameterMode, ParameterMode),
    JumpIfFalse(ParameterMode, ParameterMode),
    LessThan(ParameterMode, ParameterMode, ParameterMode),
    Equals(ParameterMode, ParameterMode, ParameterMode),
    AdjustRelativeBase(ParameterMode)
}

#[derive(Copy,Clone,Debug)]
enum TileType
{
    Visited,
    Wall,
    Oxygen
}

#[derive(Copy,Clone)]
enum Direction
{
    North,
    South,
    West,
    East
}

#[derive(Copy,Clone)]
enum InputMode
{
    Interactive,
    Automatic
}

struct IntProgram<T> where T: IOHandler
{
    memory: HashMap<Address, InstructionByte>,
    relative_base: InstructionByte,
    io: T,
    halt: bool
}

trait IOHandler
{
    fn input_handler(& mut self) -> Option<IOData>;
    fn output_handler(& mut self, data: IOData);
}

struct Program
{
    x_pos: IOData,
    y_pos: IOData,
    min_x: IOData,
    max_x: IOData,
    min_y: IOData,
    max_y: IOData,
    oxy_x: IOData,
    oxy_y: IOData,
    game_state: HashMap<(IOData, IOData), TileType>,
    input_mode: InputMode,
    show_game_state: bool,
    last_movement: Direction,
    last_tile: TileType,
    steps: usize,
    max_steps: Option<usize>
}


// ------------------ //
//  -->>  Main  <<--  //
// ------------------ //

fn main()
{
    let program = Program::new(InputMode::Automatic, Some(2500));
    let mut int_program = IntProgram::new(
        get_program_instructions(),
        program
    );
    int_program.execute();
    println!("Shortest path: {}", int_program.io.find_shortest());
    println!("");
}

impl Program
{
    fn new(input_mode: InputMode, max_steps: Option<usize>) -> Self
    {
        let mut game_state = HashMap::<(IOData, IOData), TileType>::new();
        game_state.insert((0, 0), TileType::Visited);

        return Program
        {
            x_pos: 0,
            y_pos: 0,
            min_x: 0,
            max_x: 0,
            min_y: 0,
            max_y: 0,
            oxy_x: 0,
            oxy_y: 0,
            game_state: game_state,
            input_mode: input_mode,
            show_game_state: match input_mode { InputMode::Interactive => true, _ => false },
            last_movement: Direction::North,
            last_tile: TileType::Visited,
            steps: 0,
            max_steps: max_steps
        };
    }

    fn find_shortest(&self) -> usize
    {
        let mut q = Vec::new();
        q.push((0, None, (self.oxy_x, self.oxy_y)));

        loop
        {
            let dq = q.remove(0);
            let steps = dq.0;
            let dir = dq.1;
            let pos = dq.2;

            if (pos == (0, 0))
            {
                return steps;
            }

            let mut new_pos = Vec::new();
            if !matches!(dir, Some(Direction::North))
            {
                new_pos.push((Some(Direction::South), (pos.0, pos.1+1)));
            }
            if !matches!(dir, Some(Direction::South))
            {
                new_pos.push((Some(Direction::North), (pos.0, pos.1-1)));
            }
            if !matches!(dir, Some(Direction::West))
            {
                new_pos.push((Some(Direction::East),  (pos.0+1, pos.1)));
            }
            if !matches!(dir, Some(Direction::East))
            {
                new_pos.push((Some(Direction::West),  (pos.0-1, pos.1)));
            }

            for (dir, pos) in new_pos
            {
                match self.game_state.get(&pos)
                {
                    Some(TileType::Visited) =>
                    {
                        q.push((steps+1, dir, pos));
                    },
                    _ => {}
                };
            }
        }
    }

    fn print_game_state(&self)
    {
        for y in (self.min_y)..(self.max_y + 1)
        {
            for x in (self.min_x)..(self.max_x + 1)
            {
                if x == self.x_pos && y == self.y_pos
                {
                    print!("¤");
                }
                else
                {
                    print!("{}", match self.game_state.get(&(x, y))
                    {
                        Some(TileType::Visited) => '.',
                        Some(TileType::Wall)    => '▢',
                        Some(TileType::Oxygen)  => '●',
                        None => ' '
                    });
                }
            }
            println!("");
        }
        println!("Steps: {}", self.steps);
        println!("");
    }

    fn decide_next_move(&self) -> IOData
    {
        let mut direction = self.last_movement;

        if matches!(self.last_tile, TileType::Wall)
        {
            direction = turn_left(&direction);
        }
        else
        {
            direction = turn_right(&direction);
        }

        let pos = (self.x_pos, self.y_pos);

        loop
        {
            match self.game_state.get(&move_pos(pos, direction))
            {
                Some(TileType::Visited) => return dir_to_int(&direction),
                None => return dir_to_int(&direction),
                _ => direction = turn_left(&direction)
            }
        }
    }
}

fn move_pos(position: (IOData, IOData), direction: Direction) -> (IOData, IOData)
{
    let x = position.0;
    let y = position.1;

    match direction
    {
        Direction::North => (x, y - 1),
        Direction::South => (x, y + 1),
        Direction::West  => (x - 1, y),
        Direction::East  => (x + 1, y)
    }
}

fn turn_right(direction: &Direction) -> Direction
{
    match direction
    {
        Direction::North => Direction::East,
        Direction::East  => Direction::South,
        Direction::South => Direction::West,
        Direction::West  => Direction::North
    }
}

fn turn_left(direction: &Direction) -> Direction
{
    match direction
    {
        Direction::East  => Direction::North,
        Direction::North => Direction::West,
        Direction::West  => Direction::South,
        Direction::South => Direction::East
    }
}

fn dir_to_int(direction: &Direction) -> IOData
{
    return match direction
    {
        Direction::North => 1,
        Direction::South => 2,
        Direction::West  => 3,
        Direction::East  => 4
    };
}

fn get_int_input() -> Option<IOData>
{
    let mut line = String::new();

    let _ = std::io::stdin()
        .read_line(&mut line)
        .expect("Failed to read from stdin!");

    let result = line.trim()
        .parse::<IOData>();

    return match result
    {
        Ok(value) => Some(value),
        _ => None
    };
}

impl IOHandler for Program
{
    fn input_handler(& mut self) -> Option<IOData>
    {
        if self.show_game_state
        {
            self.print_game_state();
        }

        let movement = match self.input_mode
        {
            InputMode::Interactive =>
            {
                let mut result: Option<IOData> = None;
                while result.is_none()
                {
                    result = get_int_input();

                    match result
                    {
                        None => println!("Not an integer!"),
                        Some(mv) if mv < 1 || mv > 4 =>
                        {
                            println!("Invalid input!");
                            result = None;
                        },
                        _ => {}
                    }
                }

                println!();
                result.unwrap()
            },
            InputMode::Automatic => self.decide_next_move()
        };

        self.last_movement = match movement
        {
            1 => Direction::North,
            2 => Direction::South,
            3 => Direction::West,
            4 => Direction::East,
            _ => panic!()
        };

        self.steps += 1;
        if self.max_steps.is_some() && self.max_steps.unwrap() < self.steps
        {
            self.print_game_state();
            println!("Max number of steps reached!");
            return None; // means 'halt'
        }
        return Some(movement);
    }

    fn output_handler(& mut self, data: IOData)
    {
        let new_pos = move_pos((self.x_pos, self.y_pos), self.last_movement);

        self.min_x = cmp::min(self.min_x, new_pos.0);
        self.min_y = cmp::min(self.min_y, new_pos.1);
        self.max_x = cmp::max(self.max_x, new_pos.0);
        self.max_y = cmp::max(self.max_y, new_pos.1);

        let tile : TileType;
        match data
        {
            0 => // Wall
            {
                tile = TileType::Wall;
            }
            1 => // Moved one step
            {
                tile = TileType::Visited;
                self.x_pos = new_pos.0;
                self.y_pos = new_pos.1;
            }
            2 => // Moved one step, found oxygen
            {
                tile = TileType::Oxygen;
                self.x_pos = new_pos.0;
                self.y_pos = new_pos.1;
                self.oxy_x = new_pos.0;
                self.oxy_y = new_pos.1;
            }
            _ => panic!()
        };

        *self.game_state.entry(new_pos).or_insert(TileType::Visited) = tile;
        self.last_tile = tile;
    }
}

impl<T: IOHandler> IntProgram<T>
{
    fn new(instructions: Vec<InstructionByte>, io: T) -> Self
    {
        let mut program = IntProgram
        {
            memory: HashMap::<Address,InstructionByte>::new(),
            relative_base: 0,
            io: io,
            halt: false
        };

        let mut addr: Address = 0;
        for instr in instructions
        {
            program.memory.insert(addr, instr);
            addr += 1;
        }

        return program;
    }

    fn execute(& mut self)
    {
        let mut instr_ptr: Address = 0;
        let mut instr_ptr_wrapped = Some(instr_ptr);

        while instr_ptr_wrapped != None
        {
            instr_ptr = instr_ptr_wrapped.unwrap();
            let instruction = self.decode_opcode(self.read_memory(instr_ptr));

            instr_ptr_wrapped = match instruction
            {
                Instruction::Add(p1_mode, p2_mode, p3_mode) => self.add(instr_ptr, p1_mode, p2_mode, p3_mode),
                Instruction::Multiply(p1_mode, p2_mode, p3_mode) => self.multiply(instr_ptr, p1_mode, p2_mode, p3_mode),
                Instruction::Input(p1_mode) => self.input(instr_ptr, p1_mode),
                Instruction::Output(p1_mode) => self.output(instr_ptr, p1_mode),
                Instruction::JumpIfTrue(p1_mode, p2_mode) => self.jump_if_true(instr_ptr, p1_mode, p2_mode),
                Instruction::JumpIfFalse(p1_mode, p2_mode) => self.jump_if_false(instr_ptr, p1_mode, p2_mode),
                Instruction::LessThan(p1_mode, p2_mode, p3_mode) => self.less_than(instr_ptr, p1_mode, p2_mode, p3_mode),
                Instruction::Equals(p1_mode, p2_mode, p3_mode) => self.equals(instr_ptr, p1_mode, p2_mode, p3_mode),
                Instruction::AdjustRelativeBase(p1_mode) => self.adjust_relative_base(instr_ptr, p1_mode),
                Instruction::Exit => self.exit()
            };
        }
    }


// ----------------------------------------- //
//  -->>  Instruction implementations  <<--  //
// ----------------------------------------- //

    fn add(& mut self, instr_ptr: Address, p1_mode: ParameterMode, p2_mode: ParameterMode, p3_mode: ParameterMode) -> Option<Address>
    {
        self.set_value(
            self.read_memory(instr_ptr + 3 as Address),
            self.get_value(instr_ptr+1, p1_mode) +
            self.get_value(instr_ptr+2, p2_mode),
            p3_mode
        );

        return Some(instr_ptr + 4);
    }

    fn multiply(& mut self, instr_ptr: Address, p1_mode: ParameterMode, p2_mode: ParameterMode, p3_mode: ParameterMode) -> Option<Address>
    {
        self.set_value(
            self.read_memory(instr_ptr + 3 as Address),
            self.get_value(instr_ptr+1, p1_mode) *
            self.get_value(instr_ptr+2, p2_mode),
            p3_mode
        );

        return Some(instr_ptr + 4);
    }

    fn input(& mut self, instr_ptr: Address, p1_mode: ParameterMode) -> Option<Address>
    {
        let data = self.io.input_handler();
        if data.is_none()
        {
            self.halt = true;
            return None;
        }

        self.set_value(
            self.read_memory(instr_ptr + 1),
            data.unwrap(),
            p1_mode
        );

        return Some(instr_ptr + 2);
    }

    fn output(& mut self, instr_ptr: Address, p1_mode: ParameterMode) -> Option<Address>
    {
        let value = self.get_value(instr_ptr+1, p1_mode);
        self.io.output_handler(value);
        return Some(instr_ptr + 2);
    }

    fn jump_if_true(& mut self, instr_ptr: Address, p1_mode: ParameterMode, p2_mode: ParameterMode) -> Option<Address>
    {
        let compare_value = self.get_value(instr_ptr+1, p1_mode);

        if compare_value == 0
        {
            return Some(instr_ptr + 3)
        }

        let target_address = self.get_value(instr_ptr+2, p2_mode) as Address;
        return Some(target_address);
    }

    fn jump_if_false(& mut self, instr_ptr: Address, p1_mode: ParameterMode, p2_mode: ParameterMode) -> Option<Address>
    {
        let compare_value = self.get_value(instr_ptr+1, p1_mode);

        if compare_value != 0
        {
            return Some(instr_ptr + 3)
        }

        let target_address = self.get_value(instr_ptr+2, p2_mode) as Address;
        return Some(target_address);
    }

    fn less_than(& mut self, instr_ptr: Address, p1_mode: ParameterMode, p2_mode: ParameterMode, p3_mode: ParameterMode) -> Option<Address>
    {
        self.set_value(
            self.read_memory(instr_ptr + 3),
            match
                self.get_value(instr_ptr+1, p1_mode) <
                self.get_value(instr_ptr+2, p2_mode)
            {
                true => 1,
                false => 0
            },
            p3_mode);

        return Some(instr_ptr + 4);
    }

    fn equals(& mut self, instr_ptr: Address, p1_mode: ParameterMode, p2_mode: ParameterMode, p3_mode: ParameterMode) -> Option<Address>
    {
        self.set_value(
            self.read_memory(instr_ptr + 3),
            match
                self.get_value(instr_ptr+1, p1_mode) ==
                self.get_value(instr_ptr+2, p2_mode)
            {
                true => 1,
                false => 0
            },
            p3_mode);

        return Some(instr_ptr + 4);
    }

    fn adjust_relative_base(& mut self, instr_ptr: Address, p1_mode: ParameterMode) -> Option<Address>
    {
        self.relative_base += self.get_value(instr_ptr + 1, p1_mode);
        return Some(instr_ptr + 2);
    }

    fn exit(&self) -> Option<Address>
    {
        return None;
    }


// ------------------------------------------------- //
//  -->>  Instruction handling infrastructure  <<--  //
// ------------------------------------------------- //

    fn decode_opcode(&self, opcode: InstructionByte) -> Instruction
    {
        let full_opcode_str = format!("{:05}", opcode);
        let opcode_str = full_opcode_str.get(3..5).unwrap();

        let mode_1 = self.decode_parameter_mode(
            full_opcode_str.get(2..3)
            .unwrap());

        let mode_2 = self.decode_parameter_mode(
            full_opcode_str.get(1..2)
            .unwrap());

        let mode_3 = self.decode_parameter_mode(
            full_opcode_str.get(0..1)
            .unwrap());

        return match opcode_str
        {
            "01" => Instruction::Add(mode_1, mode_2, mode_3),
            "02" => Instruction::Multiply(mode_1, mode_2, mode_3),
            "03" => Instruction::Input(mode_1),
            "04" => Instruction::Output(mode_1),
            "05" => Instruction::JumpIfTrue(mode_1, mode_2),
            "06" => Instruction::JumpIfFalse(mode_1, mode_2),
            "07" => Instruction::LessThan(mode_1, mode_2, mode_3),
            "08" => Instruction::Equals(mode_1, mode_2, mode_3),
            "09" => Instruction::AdjustRelativeBase(mode_1),
            "99" => Instruction::Exit,
            _ => panic!("Invalid instruction {}", opcode_str)
        };
    }

    fn read_memory(&self, address: Address) -> InstructionByte
    {
        return match self.memory.get(&address)
        {
            Some(value) => *value,
            None => 0 as InstructionByte
        };
    }

    fn get_value(&self, address: Address, parameter_mode: ParameterMode) -> InstructionByte
    {
        let value: InstructionByte = self.read_memory(address);

        return match parameter_mode
        {
            ParameterMode::Immediate => value,
            ParameterMode::Positional => self.read_memory(value),
            ParameterMode::Relative => self.read_memory(self.relative_base + value)
        };
    }

    fn set_value(& mut self, address: Address, value: InstructionByte, parameter_mode: ParameterMode)
    {
        let target_address = match parameter_mode
        {
            ParameterMode::Immediate => panic!("Cannot write data in immediate mode!"),
            ParameterMode::Positional => address,
            ParameterMode::Relative => (self.relative_base + address)
        };

        *self.memory.entry(target_address).or_insert(1) = value;
    }

    fn decode_parameter_mode(&self, input: &str) -> ParameterMode
    {
        let mode = match input
        {
            "0" => ParameterMode::Positional,
            "1" => ParameterMode::Immediate,
            "2" => ParameterMode::Relative,
            _ => panic!("Invalid paramter mode!")
        };

        return mode;
    }
}

// ------------------------ //
//  -->>  Input data  <<--  //
// ------------------------ //
fn get_program_instructions() -> Vec<InstructionByte>
{
    return vec![
        //  -->>  Day 15 puzzle input  <<--
        // ---------------------------------
        3,1033,1008,1033,1,1032,1005,1032,31,1008,1033,2,1032,1005,1032,58,1008,1033,3,1032,1005,1032,81,1008,1033,4,1032,1005,1032,104,99,1002,1034,1,1039,102,1,1036,1041,1001,1035,-1,1040,1008,1038,0,1043,102,-1,1043,1032,1,1037,1032,1042,1105,1,124,1002,1034,1,1039,101,0,1036,1041,1001,1035,1,1040,1008,1038,0,1043,1,1037,1038,1042,1106,0,124,1001,1034,-1,1039,1008,1036,0,1041,101,0,1035,1040,1001,1038,0,1043,1001,1037,0,1042,1105,1,124,1001,1034,1,1039,1008,1036,0,1041,1002,1035,1,1040,102,1,1038,1043,101,0,1037,1042,1006,1039,217,1006,1040,217,1008,1039,40,1032,1005,1032,217,1008,1040,40,1032,1005,1032,217,1008,1039,37,1032,1006,1032,165,1008,1040,37,1032,1006,1032,165,1102,1,2,1044,1106,0,224,2,1041,1043,1032,1006,1032,179,1101,1,0,1044,1105,1,224,1,1041,1043,1032,1006,1032,217,1,1042,1043,1032,1001,1032,-1,1032,1002,1032,39,1032,1,1032,1039,1032,101,-1,1032,1032,101,252,1032,211,1007,0,73,1044,1105,1,224,1102,1,0,1044,1105,1,224,1006,1044,247,1002,1039,1,1034,1001,1040,0,1035,101,0,1041,1036,101,0,1043,1038,101,0,1042,1037,4,1044,1105,1,0,58,87,52,69,28,16,88,43,75,16,91,2,94,51,62,80,96,46,64,98,72,8,54,71,47,84,88,44,81,7,90,13,80,42,62,68,85,27,34,2,13,89,87,79,63,76,9,82,58,60,93,63,78,79,43,32,84,25,34,80,87,15,89,96,1,50,75,25,67,82,27,3,89,48,99,33,36,77,86,62,99,19,86,92,6,56,24,96,2,79,9,3,84,41,94,79,76,91,66,50,82,88,85,13,88,18,93,79,12,98,46,75,52,99,95,11,16,25,17,77,55,87,17,74,76,81,41,77,80,92,46,20,99,22,16,41,90,64,89,53,3,61,88,97,14,2,33,79,62,79,90,80,77,71,45,40,51,62,67,82,42,27,97,17,72,77,12,38,97,85,85,35,92,82,3,84,96,40,27,93,96,18,45,98,16,49,82,52,90,43,81,10,88,94,15,42,77,67,84,88,51,35,84,20,99,7,9,79,65,86,39,93,52,98,11,19,83,75,92,27,72,77,77,78,99,18,53,35,75,14,23,90,15,83,15,98,74,14,75,67,98,93,64,97,97,58,77,88,28,19,1,82,96,69,92,34,1,90,45,79,27,25,85,59,89,88,13,91,93,38,95,55,24,61,79,56,63,61,80,10,76,84,24,80,41,83,37,86,81,93,53,33,75,78,6,81,66,84,98,3,37,84,48,89,88,70,93,96,17,94,38,82,39,74,65,90,9,77,55,53,78,10,98,27,96,11,18,86,54,98,53,86,66,19,93,52,99,44,85,79,19,7,53,86,13,90,46,33,86,19,52,79,60,92,94,97,4,99,83,67,84,58,10,96,5,91,75,47,74,93,68,76,74,50,45,99,15,85,13,99,96,30,99,84,59,81,51,64,74,9,27,2,99,34,49,76,61,28,87,56,84,81,32,6,88,48,57,89,43,76,77,15,80,91,45,9,6,52,93,84,77,17,82,32,67,97,92,74,54,46,99,80,5,83,74,85,64,89,36,41,77,47,94,24,86,45,23,99,59,90,43,61,95,98,91,90,33,91,15,19,88,49,54,86,75,42,67,43,54,97,10,10,42,85,10,11,60,76,17,90,43,80,80,34,90,85,71,70,40,80,97,31,55,80,3,58,99,31,31,99,31,90,90,57,29,85,76,22,14,77,76,87,21,88,77,85,33,81,77,94,57,56,18,83,54,90,90,2,89,87,36,13,85,36,85,70,96,20,85,82,43,34,97,93,27,40,44,80,97,2,81,16,44,12,91,35,90,24,49,75,71,96,5,29,65,80,87,35,51,92,43,94,30,84,88,10,99,4,71,76,65,77,71,1,89,90,58,28,77,42,57,81,87,13,16,72,74,32,98,83,8,75,79,10,96,11,92,34,84,13,1,77,78,71,21,63,78,37,98,86,53,84,75,1,60,75,66,86,22,78,32,31,78,97,97,89,23,88,78,4,75,59,99,65,13,85,70,74,77,83,39,62,76,81,33,98,87,25,41,90,48,42,33,24,94,86,15,94,89,21,23,81,29,36,99,93,60,20,90,19,66,52,90,80,97,95,21,86,45,80,78,7,37,80,84,22,6,97,79,34,87,27,43,52,97,84,72,9,89,93,2,75,82,60,92,12,87,89,59,74,64,90,38,71,89,12,26,81,6,53,78,96,8,81,91,69,68,89,76,79,50,77,19,83,14,75,26,76,34,78,1,83,70,80,39,99,62,95,89,99,6,79,93,80,10,83,50,79,80,92,41,78,20,86,9,84,53,87,13,74,0,0,21,21,1,10,1,0,0,0,0,0,0
        // ---------------------------------

        //  -->>  Day 13 puzzle input  <<--
        // ---------------------------------
        // Memory address [0] is 1 for part 1 and 2 for part 2...
        // 2,380,379,385,1008,2655,990435,381,1005,381,12,99,109,2656,1101,0,0,383,1102,1,0,382,21002,382,1,1,21001,383,0,2,21102,1,37,0,1105,1,578,4,382,4,383,204,1,1001,382,1,382,1007,382,42,381,1005,381,22,1001,383,1,383,1007,383,24,381,1005,381,18,1006,385,69,99,104,-1,104,0,4,386,3,384,1007,384,0,381,1005,381,94,107,0,384,381,1005,381,108,1106,0,161,107,1,392,381,1006,381,161,1101,0,-1,384,1106,0,119,1007,392,40,381,1006,381,161,1101,1,0,384,21002,392,1,1,21101,22,0,2,21102,0,1,3,21102,138,1,0,1106,0,549,1,392,384,392,20102,1,392,1,21101,22,0,2,21102,3,1,3,21101,161,0,0,1105,1,549,1101,0,0,384,20001,388,390,1,20102,1,389,2,21101,180,0,0,1105,1,578,1206,1,213,1208,1,2,381,1006,381,205,20001,388,390,1,20102,1,389,2,21102,1,205,0,1105,1,393,1002,390,-1,390,1101,1,0,384,20101,0,388,1,20001,389,391,2,21101,228,0,0,1106,0,578,1206,1,261,1208,1,2,381,1006,381,253,20101,0,388,1,20001,389,391,2,21102,1,253,0,1105,1,393,1002,391,-1,391,1102,1,1,384,1005,384,161,20001,388,390,1,20001,389,391,2,21102,279,1,0,1105,1,578,1206,1,316,1208,1,2,381,1006,381,304,20001,388,390,1,20001,389,391,2,21102,304,1,0,1106,0,393,1002,390,-1,390,1002,391,-1,391,1101,1,0,384,1005,384,161,21001,388,0,1,20102,1,389,2,21102,1,0,3,21102,1,338,0,1106,0,549,1,388,390,388,1,389,391,389,20101,0,388,1,20102,1,389,2,21102,1,4,3,21101,365,0,0,1106,0,549,1007,389,23,381,1005,381,75,104,-1,104,0,104,0,99,0,1,0,0,0,0,0,0,273,19,19,1,1,21,109,3,22102,1,-2,1,22101,0,-1,2,21102,1,0,3,21102,414,1,0,1105,1,549,22101,0,-2,1,21202,-1,1,2,21101,429,0,0,1106,0,601,2101,0,1,435,1,386,0,386,104,-1,104,0,4,386,1001,387,-1,387,1005,387,451,99,109,-3,2106,0,0,109,8,22202,-7,-6,-3,22201,-3,-5,-3,21202,-4,64,-2,2207,-3,-2,381,1005,381,492,21202,-2,-1,-1,22201,-3,-1,-3,2207,-3,-2,381,1006,381,481,21202,-4,8,-2,2207,-3,-2,381,1005,381,518,21202,-2,-1,-1,22201,-3,-1,-3,2207,-3,-2,381,1006,381,507,2207,-3,-4,381,1005,381,540,21202,-4,-1,-1,22201,-3,-1,-3,2207,-3,-4,381,1006,381,529,22101,0,-3,-7,109,-8,2106,0,0,109,4,1202,-2,42,566,201,-3,566,566,101,639,566,566,1202,-1,1,0,204,-3,204,-2,204,-1,109,-4,2106,0,0,109,3,1202,-1,42,594,201,-2,594,594,101,639,594,594,20101,0,0,-2,109,-3,2105,1,0,109,3,22102,24,-2,1,22201,1,-1,1,21101,0,509,2,21102,646,1,3,21101,1008,0,4,21102,1,630,0,1105,1,456,21201,1,1647,-2,109,-3,2106,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,0,2,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,2,0,2,0,0,0,2,2,2,2,2,0,0,0,2,2,0,0,2,0,1,1,0,0,2,2,0,2,0,2,2,0,0,0,0,2,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,1,1,0,0,0,2,0,2,0,0,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,0,2,0,0,0,2,2,0,0,0,2,0,1,1,0,0,2,2,2,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,1,1,0,0,2,2,2,2,0,2,0,0,2,0,0,2,2,2,2,0,0,0,0,0,0,0,0,2,0,2,2,2,0,0,2,0,0,0,2,2,0,0,1,1,0,0,0,0,2,0,0,0,2,0,2,2,0,0,2,0,0,2,0,2,2,2,0,2,2,2,2,2,2,0,0,2,0,0,0,2,2,2,0,0,1,1,0,2,2,2,0,2,0,0,0,2,2,2,0,0,0,2,2,0,0,2,2,2,2,2,2,0,2,0,0,0,0,0,0,2,2,0,0,0,2,0,1,1,0,2,0,2,2,2,2,2,2,2,0,2,2,2,0,0,2,0,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,2,0,0,0,1,1,0,2,2,0,0,2,0,0,0,0,2,0,0,2,2,0,0,2,2,0,2,2,2,0,0,0,2,2,2,0,2,2,0,0,0,2,0,0,2,0,1,1,0,0,0,0,0,2,0,2,0,2,2,2,2,0,0,0,2,0,2,0,2,0,0,0,0,0,2,2,0,2,2,0,0,0,2,2,2,2,0,0,1,1,0,0,0,2,2,0,0,2,2,0,0,0,2,2,2,0,2,2,2,0,0,2,2,0,0,2,0,0,0,0,2,0,2,2,0,0,0,2,0,0,1,1,0,0,0,0,2,2,0,0,0,0,2,2,2,0,2,0,0,0,2,2,0,0,2,2,2,0,2,0,2,2,0,0,2,0,0,0,2,2,2,0,1,1,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,2,0,2,2,2,0,2,2,0,0,2,0,0,2,2,0,0,1,1,0,2,2,0,0,2,0,0,0,0,0,2,0,2,0,0,2,2,0,0,2,0,0,0,0,0,2,0,0,2,0,2,0,2,2,0,2,0,0,0,1,1,0,2,0,2,2,0,2,0,0,0,0,0,0,0,0,2,2,0,2,0,0,2,0,2,0,2,0,2,2,0,2,0,2,2,0,0,0,0,2,0,1,1,0,0,2,0,2,2,0,0,2,2,2,0,0,0,2,2,2,2,0,2,0,2,0,0,2,0,2,0,2,0,0,2,0,2,0,2,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,6,36,24,85,66,70,87,60,26,72,78,96,17,40,97,35,47,41,13,71,87,40,95,60,61,79,41,31,4,6,72,88,63,33,79,38,41,34,3,11,4,27,85,37,24,77,81,5,33,59,50,51,28,42,14,69,71,14,35,13,5,20,29,44,78,8,18,63,26,98,35,57,68,94,68,34,81,30,41,1,27,71,55,61,57,42,61,3,11,16,50,42,15,53,95,17,77,60,93,39,72,17,23,8,50,14,70,65,29,79,96,23,24,31,57,83,20,58,77,69,59,92,75,89,27,58,33,46,64,28,15,95,50,62,11,30,65,37,81,47,55,29,75,69,83,14,41,31,83,71,76,4,74,88,64,94,36,63,31,72,34,7,12,49,76,8,64,18,49,74,95,18,38,32,96,63,36,58,38,16,79,5,17,28,80,42,49,87,19,51,27,77,70,85,78,28,24,47,87,67,72,50,80,47,57,83,48,18,30,10,50,36,84,90,28,73,15,97,86,79,75,31,65,3,98,13,39,90,8,38,69,22,32,26,87,60,47,56,79,58,46,54,24,75,37,33,58,41,67,84,42,30,59,29,3,29,88,83,46,16,94,48,48,72,80,5,28,16,23,47,74,91,79,80,14,34,88,83,9,88,96,15,62,79,53,27,10,76,98,74,27,18,75,92,73,88,92,62,39,12,34,73,86,65,50,86,36,20,46,42,65,15,63,40,20,45,57,38,44,89,42,8,9,24,43,96,4,87,37,46,78,29,56,70,17,76,96,12,9,37,32,59,45,97,19,97,46,35,19,22,28,42,54,81,67,29,57,85,18,94,45,96,87,98,15,20,2,95,15,53,15,33,9,69,31,3,56,9,25,41,31,43,27,54,21,89,6,37,58,52,66,11,3,21,5,41,78,79,4,13,77,77,70,26,12,61,58,61,93,71,53,52,67,93,6,2,18,13,94,41,22,82,61,8,96,76,92,69,58,41,18,13,28,46,80,62,13,51,43,90,45,7,14,75,35,68,62,54,19,67,93,35,69,97,18,58,37,21,21,88,92,24,40,64,83,24,74,15,52,60,71,79,53,63,85,2,53,80,95,28,51,63,5,38,26,18,94,60,61,88,17,41,74,27,37,15,24,91,88,13,3,55,55,18,11,32,79,19,84,42,26,46,10,31,47,28,68,11,15,33,61,14,40,48,49,7,40,54,61,23,82,23,4,87,56,56,16,7,28,28,2,21,21,51,70,81,13,63,90,17,88,89,14,77,61,69,83,71,98,59,23,40,57,46,89,10,13,66,19,64,22,2,25,19,49,55,70,56,92,47,64,27,16,76,68,66,90,1,88,31,20,74,68,76,47,37,83,94,45,67,53,33,63,27,40,10,63,23,88,32,86,37,25,52,80,70,6,45,41,84,56,11,3,59,9,70,6,58,94,74,67,8,27,54,80,78,37,61,52,66,24,45,55,5,66,43,54,84,61,26,6,64,92,15,43,75,20,32,83,56,82,44,18,76,13,11,89,4,91,20,20,88,43,96,28,73,73,57,98,29,39,45,73,84,36,2,47,18,36,64,38,83,54,26,21,50,37,98,3,83,90,35,19,3,27,58,49,38,2,40,19,18,95,41,8,47,45,8,30,55,86,96,97,48,10,59,89,46,71,86,14,94,54,25,1,2,78,29,91,65,51,26,2,57,27,97,9,20,1,1,47,94,18,20,57,68,24,46,8,68,98,88,88,85,76,24,82,70,86,35,42,87,6,73,62,95,98,6,77,60,86,89,76,57,18,29,7,90,51,54,20,28,93,60,8,25,49,28,7,34,6,68,79,92,10,18,55,43,85,20,47,46,15,47,80,81,46,65,47,38,2,67,92,86,54,33,22,71,36,3,2,71,96,36,21,70,60,58,39,71,48,74,25,94,43,44,7,55,66,87,97,53,44,72,47,39,94,76,45,62,57,57,48,15,82,14,60,58,32,65,42,68,27,72,35,85,14,79,61,16,85,11,86,35,32,13,68,70,14,13,27,47,10,26,35,60,93,10,13,75,42,77,34,59,70,5,53,62,62,91,57,20,96,71,61,8,57,21,45,72,44,5,23,67,64,32,97,52,78,34,26,69,76,58,69,77,71,64,94,10,95,71,68,15,25,42,87,78,89,58,25,11,54,75,29,74,90,89,25,90,58,98,82,5,15,35,49,69,68,10,23,87,87,74,46,53,22,83,84,64,5,9,68,59,54,24,22,20,61,4,2,59,84,79,77,72,95,80,33,12,23,3,14,23,61,18,49,32,990435
        // Arkanoid game
        // ---------------------------------

        //  -->>  Day 11 puzzle input  <<--
        // ---------------------------------
        // 3,8,1005,8,329,1106,0,11,0,0,0,104,1,104,0,3,8,102,-1,8,10,1001,10,1,10,4,10,1008,8,0,10,4,10,1002,8,1,29,2,1102,1,10,1,1009,16,10,2,4,4,10,1,9,5,10,3,8,1002,8,-1,10,101,1,10,10,4,10,108,0,8,10,4,10,101,0,8,66,2,106,7,10,1006,0,49,3,8,1002,8,-1,10,101,1,10,10,4,10,108,1,8,10,4,10,1002,8,1,95,1006,0,93,3,8,102,-1,8,10,1001,10,1,10,4,10,108,1,8,10,4,10,102,1,8,120,1006,0,61,2,1108,19,10,2,1003,2,10,1006,0,99,3,8,1002,8,-1,10,1001,10,1,10,4,10,1008,8,0,10,4,10,101,0,8,157,3,8,102,-1,8,10,1001,10,1,10,4,10,1008,8,1,10,4,10,1001,8,0,179,2,1108,11,10,1,1102,19,10,3,8,102,-1,8,10,1001,10,1,10,4,10,1008,8,1,10,4,10,101,0,8,209,2,108,20,10,3,8,1002,8,-1,10,101,1,10,10,4,10,108,1,8,10,4,10,101,0,8,234,3,8,102,-1,8,10,101,1,10,10,4,10,108,0,8,10,4,10,1002,8,1,256,2,1102,1,10,1006,0,69,2,108,6,10,2,4,13,10,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,0,10,4,10,1002,8,1,294,1,1107,9,10,1006,0,87,2,1006,8,10,2,1001,16,10,101,1,9,9,1007,9,997,10,1005,10,15,99,109,651,104,0,104,1,21101,387395195796,0,1,21101,346,0,0,1105,1,450,21101,0,48210129704,1,21101,0,357,0,1105,1,450,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,21101,0,46413147328,1,21102,404,1,0,1106,0,450,21102,179355823323,1,1,21101,415,0,0,1105,1,450,3,10,104,0,104,0,3,10,104,0,104,0,21102,1,838345843476,1,21101,0,438,0,1105,1,450,21101,709475709716,0,1,21101,449,0,0,1105,1,450,99,109,2,22102,1,-1,1,21102,40,1,2,21101,0,481,3,21101,0,471,0,1105,1,514,109,-2,2105,1,0,0,1,0,0,1,109,2,3,10,204,-1,1001,476,477,492,4,0,1001,476,1,476,108,4,476,10,1006,10,508,1101,0,0,476,109,-2,2106,0,0,0,109,4,2101,0,-1,513,1207,-3,0,10,1006,10,531,21101,0,0,-3,21201,-3,0,1,21201,-2,0,2,21101,1,0,3,21101,550,0,0,1105,1,555,109,-4,2106,0,0,109,5,1207,-3,1,10,1006,10,578,2207,-4,-2,10,1006,10,578,21201,-4,0,-4,1105,1,646,22101,0,-4,1,21201,-3,-1,2,21202,-2,2,3,21101,597,0,0,1105,1,555,22102,1,1,-4,21101,0,1,-1,2207,-4,-2,10,1006,10,616,21101,0,0,-1,22202,-2,-1,-2,2107,0,-3,10,1006,10,638,22102,1,-1,1,21101,638,0,0,106,0,513,21202,-2,-1,-2,22201,-4,-2,-4,109,-5,2106,0,0
        // Paint robot, expected result depends on input
        // ---------------------------------

        //  -->>  Day 9 puzzle input  <<--
        // --------------------------------
        // 1102,34463338,34463338,63,1007,63,34463338,63,1005,63,53,1101,3,0,1000,109,988,209,12,9,1000,209,6,209,3,203,0,1008,1000,1,63,1005,63,65,1008,1000,2,63,1005,63,904,1008,1000,0,63,1005,63,58,4,25,104,0,99,4,0,104,0,99,4,17,104,0,99,0,0,1101,37,0,1013,1101,426,0,1027,1101,36,0,1000,1101,0,606,1023,1102,34,1,1011,1102,1,712,1029,1102,1,27,1007,1101,831,0,1024,1102,32,1,1002,1102,1,1,1021,1101,429,0,1026,1102,1,826,1025,1101,0,717,1028,1102,1,20,1018,1101,0,24,1004,1102,31,1,1009,1101,22,0,1015,1102,38,1,1014,1102,613,1,1022,1102,29,1,1017,1102,0,1,1020,1102,1,21,1008,1102,33,1,1012,1101,0,30,1006,1101,0,28,1016,1102,1,26,1005,1102,35,1,1019,1101,25,0,1003,1102,1,23,1001,1102,1,39,1010,109,-3,2102,1,5,63,1008,63,34,63,1005,63,205,1001,64,1,64,1106,0,207,4,187,1002,64,2,64,109,-2,1201,7,0,63,1008,63,34,63,1005,63,227,1105,1,233,4,213,1001,64,1,64,1002,64,2,64,109,21,21102,40,1,3,1008,1019,37,63,1005,63,257,1001,64,1,64,1106,0,259,4,239,1002,64,2,64,109,-4,21101,41,0,2,1008,1014,38,63,1005,63,279,1105,1,285,4,265,1001,64,1,64,1002,64,2,64,109,-10,1201,4,0,63,1008,63,30,63,1005,63,307,4,291,1105,1,311,1001,64,1,64,1002,64,2,64,109,6,1207,0,22,63,1005,63,329,4,317,1105,1,333,1001,64,1,64,1002,64,2,64,109,-5,1207,5,20,63,1005,63,353,1001,64,1,64,1106,0,355,4,339,1002,64,2,64,109,8,2108,29,-5,63,1005,63,375,1001,64,1,64,1105,1,377,4,361,1002,64,2,64,109,15,1206,-6,395,4,383,1001,64,1,64,1105,1,395,1002,64,2,64,109,-11,21107,42,43,4,1005,1019,413,4,401,1106,0,417,1001,64,1,64,1002,64,2,64,109,6,2106,0,6,1105,1,435,4,423,1001,64,1,64,1002,64,2,64,109,-15,1208,-3,24,63,1005,63,455,1001,64,1,64,1105,1,457,4,441,1002,64,2,64,109,-13,1208,10,25,63,1005,63,475,4,463,1106,0,479,1001,64,1,64,1002,64,2,64,109,21,21108,43,42,3,1005,1017,495,1106,0,501,4,485,1001,64,1,64,1002,64,2,64,109,-14,2107,31,2,63,1005,63,519,4,507,1106,0,523,1001,64,1,64,1002,64,2,64,109,-4,1202,8,1,63,1008,63,24,63,1005,63,549,4,529,1001,64,1,64,1105,1,549,1002,64,2,64,109,1,2108,23,4,63,1005,63,567,4,555,1105,1,571,1001,64,1,64,1002,64,2,64,109,2,2101,0,5,63,1008,63,21,63,1005,63,591,1105,1,597,4,577,1001,64,1,64,1002,64,2,64,109,28,2105,1,-4,1001,64,1,64,1105,1,615,4,603,1002,64,2,64,109,-10,1205,4,633,4,621,1001,64,1,64,1106,0,633,1002,64,2,64,109,2,1206,2,645,1106,0,651,4,639,1001,64,1,64,1002,64,2,64,109,-4,1202,-6,1,63,1008,63,28,63,1005,63,671,1105,1,677,4,657,1001,64,1,64,1002,64,2,64,109,-9,21102,44,1,4,1008,1010,44,63,1005,63,699,4,683,1105,1,703,1001,64,1,64,1002,64,2,64,109,31,2106,0,-9,4,709,1105,1,721,1001,64,1,64,1002,64,2,64,109,-30,21108,45,45,6,1005,1013,743,4,727,1001,64,1,64,1106,0,743,1002,64,2,64,109,2,21101,46,0,3,1008,1012,46,63,1005,63,765,4,749,1106,0,769,1001,64,1,64,1002,64,2,64,109,-5,2101,0,0,63,1008,63,24,63,1005,63,795,4,775,1001,64,1,64,1105,1,795,1002,64,2,64,109,6,2107,32,-1,63,1005,63,815,1001,64,1,64,1106,0,817,4,801,1002,64,2,64,109,19,2105,1,-5,4,823,1106,0,835,1001,64,1,64,1002,64,2,64,109,-12,21107,47,46,-1,1005,1016,851,1105,1,857,4,841,1001,64,1,64,1002,64,2,64,109,-2,1205,5,873,1001,64,1,64,1105,1,875,4,863,1002,64,2,64,109,-6,2102,1,-8,63,1008,63,23,63,1005,63,897,4,881,1105,1,901,1001,64,1,64,4,64,99,21101,0,27,1,21101,0,915,0,1106,0,922,21201,1,44808,1,204,1,99,109,3,1207,-2,3,63,1005,63,964,21201,-2,-1,1,21101,942,0,0,1105,1,922,21201,1,0,-1,21201,-2,-3,1,21102,957,1,0,1105,1,922,22201,1,-1,-2,1106,0,968,21202,-2,1,-2,109,-3,2105,1,0
        // Expected result for part 1 (input 1): 2941952859
        // Expected result for part 2 (input 2): 66113
        // --------------------------------

        //  -->>  Day 9 assorted examples  <<--
        // -------------------------------------
        // 109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99
        // Expected reult: a copy of itself
        //
        // 1102,34915192,34915192,7,4,7,99,0
        // Expected reult: 1219070632396864
        //
        // 104,1125899906842624,99
        // Expected result: 1125899906842624
        // -------------------------------------

        //  -->>  Day 7 puzzle input  <<--
        // --------------------------------
        // 3,8,1001,8,10,8,105,1,0,0,21,34,59,68,89,102,183,264,345,426,99999,3,9,102,5,9,9,1001,9,5,9,4,9,99,3,9,101,3,9,9,1002,9,5,9,101,5,9,9,1002,9,3,9,1001,9,5,9,4,9,99,3,9,101,5,9,9,4,9,99,3,9,102,4,9,9,101,3,9,9,102,5,9,9,101,4,9,9,4,9,99,3,9,1002,9,5,9,1001,9,2,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,99
        // Expected result: ???
        // --------------------------------

        //  -->>  Day 5 puzzle input  <<--
        // --------------------------------
        // 3,225,1,225,6,6,1100,1,238,225,104,0,1001,210,88,224,101,-143,224,224,4,224,1002,223,8,223,101,3,224,224,1,223,224,223,101,42,92,224,101,-78,224,224,4,224,1002,223,8,223,1001,224,3,224,1,223,224,223,1101,73,10,225,1102,38,21,225,1102,62,32,225,1,218,61,224,1001,224,-132,224,4,224,102,8,223,223,1001,224,5,224,1,224,223,223,1102,19,36,225,102,79,65,224,101,-4898,224,224,4,224,102,8,223,223,101,4,224,224,1,224,223,223,1101,66,56,224,1001,224,-122,224,4,224,102,8,223,223,1001,224,2,224,1,224,223,223,1002,58,82,224,101,-820,224,224,4,224,1002,223,8,223,101,3,224,224,1,223,224,223,2,206,214,224,1001,224,-648,224,4,224,102,8,223,223,101,3,224,224,1,223,224,223,1102,76,56,224,1001,224,-4256,224,4,224,102,8,223,223,1001,224,6,224,1,223,224,223,1102,37,8,225,1101,82,55,225,1102,76,81,225,1101,10,94,225,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,8,226,677,224,102,2,223,223,1005,224,329,101,1,223,223,1008,677,677,224,1002,223,2,223,1006,224,344,1001,223,1,223,107,226,677,224,102,2,223,223,1005,224,359,1001,223,1,223,1108,677,677,224,1002,223,2,223,1006,224,374,101,1,223,223,1107,677,677,224,1002,223,2,223,1006,224,389,101,1,223,223,108,226,677,224,102,2,223,223,1006,224,404,101,1,223,223,7,677,677,224,102,2,223,223,1006,224,419,101,1,223,223,108,677,677,224,102,2,223,223,1006,224,434,1001,223,1,223,7,226,677,224,102,2,223,223,1006,224,449,1001,223,1,223,108,226,226,224,102,2,223,223,1005,224,464,101,1,223,223,8,226,226,224,1002,223,2,223,1006,224,479,101,1,223,223,1008,226,226,224,102,2,223,223,1005,224,494,1001,223,1,223,1008,677,226,224,1002,223,2,223,1005,224,509,101,1,223,223,7,677,226,224,102,2,223,223,1006,224,524,101,1,223,223,1007,677,226,224,1002,223,2,223,1006,224,539,1001,223,1,223,1108,677,226,224,102,2,223,223,1005,224,554,1001,223,1,223,8,677,226,224,1002,223,2,223,1005,224,569,101,1,223,223,1108,226,677,224,1002,223,2,223,1005,224,584,101,1,223,223,1107,677,226,224,102,2,223,223,1006,224,599,101,1,223,223,107,226,226,224,102,2,223,223,1006,224,614,1001,223,1,223,107,677,677,224,1002,223,2,223,1005,224,629,1001,223,1,223,1107,226,677,224,1002,223,2,223,1006,224,644,101,1,223,223,1007,677,677,224,102,2,223,223,1006,224,659,1001,223,1,223,1007,226,226,224,1002,223,2,223,1006,224,674,1001,223,1,223,4,223,99,226
        // Expected result for part 1 (input 1): 7259358 after a bunch of 0:es
        // Expected result for part 2 (input 5): 11826654
        // --------------------------------

        //  -->>  Day 5 assorted examples  <<--
        // -------------------------------------
        // 3,9,8,9,10,9,4,9,99,-1,8
        // using position mode, input is equal to 8 => output 1, else output 0
        //
        // 3,9,7,9,10,9,4,9,99,-1,8
        // using position mode, input is less than 8 => output 1, else output 0
        //
        // 3,3,1108,-1,8,3,4,3,99
        // using immediate mode, input is equal to 8 => output 1, esle output 0
        //
        // 3,3,1107,-1,8,3,4,3,99
        // using immediate mode, input is less than 8 => output 1, esle output 0
        //
        // 3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9
        // using position mode, jump tests input non-zero => 1, else 0
        //
        // 3,3,1105,-1,9,1101,0,0,12,4,12,99,1
        // using immediate mode, jump tests input non-zero => 1, else 0
        //
        // 3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99
        // inputs a single number. The program will then output:
        //  - 999 if the input value is below 8
        //  - 1000 if the input value is equal to 8
        //  - 1001 if the input value is greater than 8
        // ---------------------------------------------

        //  -->>  Day 2 puzzle input  <<--
        // --------------------------------
        // 1,12,2,3,1,1,2,3,1,3,4,3,1,5,0,3,2,6,1,19,2,19,9,23,1,23,5,27,2,6,27,31,1,31,5,35,1,35,5,39,2,39,6,43,2,43,10,47,1,47,6,51,1,51,6,55,2,55,6,59,1,10,59,63,1,5,63,67,2,10,67,71,1,6,71,75,1,5,75,79,1,10,79,83,2,83,10,87,1,87,9,91,1,91,10,95,2,6,95,99,1,5,99,103,1,103,13,107,1,107,10,111,2,9,111,115,1,115,6,119,2,13,119,123,1,123,6,127,1,5,127,131,2,6,131,135,2,6,135,139,1,139,5,143,1,143,10,147,1,147,2,151,1,151,13,0,99,2,0,14,0
        // Expected result: memory[0] = 4576384
        // --------------------------------
    ];
}
